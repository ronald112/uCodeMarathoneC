
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*
dirent

DIR *opendir(const char *name) - відкриває директорію з назвою "name" повертає вказіник на перший елемент у директорії DIR, повертає NULL якщо "name" недоступний, або якщо неможе виділити достатньо пам'яті для утримання всіх отриманих з деректорії даних

struct dirent *readdir(DIR *dirp) - повертає вказівник на структуру-dirent, що представляє наступний запис каталогу у потоці каталогу, на який вказує dirp. Повертає NULL після досягнення кінця потоку каталогу або якщо сталася помилка.

У Linux структуру-dirent визначають наступним чином:

struct dirent {
    ino_t          d_ino;       /* inode number */
    off_t          d_off;       /* offset to the next dirent */
    unsigned short d_reclen;    /* length of this record */
    unsigned char  d_type;      /* type of file; not supported
                                   by all file system types */
    char           d_name[256]; /* filename */
};

int closedir(DIR *dirp) - закриває потік каталогу та повертає 0 при успішній операції, при помилці виводить -1 та глобальну помилку з errno

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*
#include <sys/stat.h>

int stat(const char *path, struct stat *buf) - повертає інформацію про файл. Виводить інформацію про файл з назвою "path" та записує у buf

int lstat(const char *path, struct stat *buf) - ідентичний stat, але якщо "stat" є символьним повиланням, то саме повилання є stat-ed, а не файлом

struct stat {
    dev_t     st_dev;     /* ID of device containing file */
    ino_t     st_ino;     /* inode number */
    mode_t    st_mode;    /* protection */
    nlink_t   st_nlink;   /* number of hard links */
    uid_t     st_uid;     /* user ID of owner */
    gid_t     st_gid;     /* group ID of owner */
    dev_t     st_rdev;    /* device ID (if special file) */
    off_t     st_size;    /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
    time_t    st_atime;   /* time of last access */
    time_t    st_mtime;   /* time of last modification */
    time_t    st_ctime;   /* time of last status change */
};

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*
#include <uuid/uuid.h>

struct passwd *getpwuid(uid_t uid); - повертає вказівник на структуру, що містить розбиті поля запису в базі даних паролів, що відповідає ідентифікатору користувача ID.
#include <pwd.h>
#include <sys/types.h>

struct passwd {
   	char    *pw_name;       /* user name */
   	char    *pw_passwd;     /* encrypted password */
   	uid_t   pw_uid;         /* user uid */
   	gid_t   pw_gid;         /* user gid */
   	time_t  pw_change;      /* password change time */
   	char    *pw_class;      /* user access class */
   	char    *pw_gecos;      /* Honeywell login info */
   	char    *pw_dir;        /* home directory */
   	char    *pw_shell;      /* default shell */
   	time_t  pw_expire;      /* account expiration */
   	int     pw_fields;      /* internal: fields filled in */
};

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*

struct group *getgrgid(gid_t gid) - функція повертає вказівник на структуру, що містить розбиті поля запису в групі баз даних, що відповідає gid ідентифікатора групи

#include <grp.h>

struct group {
    char    *gr_name;       /* group name */
    char    *gr_passwd;     /* group password */
    gid_t   gr_gid;         /* group id */
    char    **gr_mem;       /* group members */
};

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*

#include <sys/xattr.h>

ssize_t 	listxattr(const char *path, char *namebuf, size_t size, int options) -  повертає список імен розширених атрибутів, пов'язаних із заданим шляхом у файловій системі.

	namebuf - це буфер даних розміром "size" для імен розширених атрибутів, пов'язаних із шляхом "path". Розширені імена атрибутів є простими NULL-кінцевими рядками UTF-8 і повертаються у довільному порядку. Між іменами в буфері не передбачено додаткових накладок. Список буде містити лише імена розширених атрибутів, до яких має доступ процес виклику. Функція повертає розмір списку імен.

ssize_t     getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options) - функція витягує до size байтів даних з розширеного атрибута name, пов'язаним з шляхом "path" у попередньо виділений буфер, на який вказується значення "value". Функція повертає кількість байтів отриманих даних.

     name - це UNT-8-рядок із завершенням NULL. position вказує зміщення в межах розширеного атрибута. У поточній реалізації цей аргумент використовується лише з
     атрибут fork fork. Для всіх інших розширених атрибутів цей параметр зарезервований і повинен бути нульовим.

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*

#include <unistd.h>

    ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize) - поміщає інформацію з символьонго посилання path в буфер buf з розміром bufsize. readlink не додає нульовий символ в buf

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*

       #include <sys/ioctl.h>
int ioctl(int fildes, unsigned long request, ...) - маніпулює основними параметрами пристрою спеціальних файлів. Зокрема, багато експлуатаційних характеристик спеціальних файлів можна змінювати запитами ioctl(). Файли аргументів повинні бути дескриптором відкритого файлу.

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*

#include <unistd.h>

int isatty(int fd);

The isatty() -функція визначає, чи є файловий дескриптор fd валідним для даної типу терміналу

*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*

#include <sys/types.h>
#include <sys/acl.h>

acl_t acl_get_file(const char *path_p, acl_type_t type) - функція отримує ACL доступ, пов'язаний з файлом або каталогом, або ACL за замовчуванням, пов'язаний з каталогом. Ім'я шляху до файлу чи каталогу вказується аргументом path_p. ACL розміщується в робочому сховищі і acl_get_file () повертає покажчик на це сховище.

char *acl_to_text(acl_t acl, ssize_t *len_p) - функція переводить ACL, на який вказує аргумент acl, в рядок символів, що закінчується NULL. Якщо вказівник len_p не є NULL, то функція повинна повертати довжину рядка (не включаючи NULL-термінатор) у місці, на яке вказує len_p

int acl_free(void *obj_p) - чистить будь-яку коректно виділенну пам>ять для acl доступу що визначений як  obj_p. Аргумент obj_p може ідентифікувати ACL, бути класифікатором запису ACL або вказівником на рядок, та бути виділений функцією acl_to_text().
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*
\33[31m - червоний колий знаків
\33[0m - за замовчуванням
\033[33 - жовтий колір знаків
\033[35 - фіолетовий колір знаків
\033[36 - колір морської хвилі знаків
\033[34 - синій колір знаків
\033[32 - зелений колір знаків
\033[30 -  чорний колір знаків

\033[40    чорний колір фону
\033[41    червоний колір фону
\033[42    зелений колір фону
\033[43    жовтий колір фону
\033[44    синий колір фону
\033[45    фіолетовий колір фону
\033[46    колір морської хвилі для фону
\033[47    сірий колір фону


test case

ls -lG /Library/ /bin/ /private/tmp/com.apple.launchd.9EGBLdES3E/Listeners
ls -Gl /bin/ps
ls -Gl /private/tmp/com.apple.launchd.9EGBLdES3E/Listeners























